<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_20) on Wed Dec 08 06:35:42 CET 2010 -->
<TITLE>
PendularDrawer (yFiles-2.8 API)
</TITLE>

<META NAME="keywords" CONTENT="y.layout.hierarchic.PendularDrawer class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../apistylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="PendularDrawer (yFiles-2.8 API)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../y/layout/hierarchic/NodeLabelSpaceDrawer.html" title="class in y.layout.hierarchic"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../y/layout/hierarchic/PolylineDrawer.html" title="class in y.layout.hierarchic"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?y/layout/hierarchic/PendularDrawer.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="PendularDrawer.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
y.layout.hierarchic</FONT>
<BR>
Class PendularDrawer</H2>
<PRE>
<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../y/layout/hierarchic/AbstractDrawer.html" title="class in y.layout.hierarchic">y.layout.hierarchic.AbstractDrawer</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>y.layout.hierarchic.PendularDrawer</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../y/layout/hierarchic/Drawer.html" title="interface in y.layout.hierarchic">Drawer</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>PendularDrawer</B><DT>extends <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html" title="class in y.layout.hierarchic">AbstractDrawer</A></DL>
</PRE>

<P>
This class implements the third phase of the Sugiyama layout algorithm
 as described in "Visualisierungstechniken f&uuml;r den Compilerbau" (Georg Sander)
 mixed with techniques as described in "A technique for drawing directed graphs"
 (Gansner et al).
<P>

<P>
<DL>
<!-- generated by yDoc 3.0_01   http://www.yworks.com/products/ydoc/   b0ac8294e88f500d32e0d39d807e8289e759a8f1e278a9... -->
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#left">left</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map that maps the left node for each node in a layer or <code>null</code> if it is the leftmost</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#right">right</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map that maps the right node for each node in a layer or <code>null</code> if it is the rightmost</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_y.layout.hierarchic.AbstractDrawer"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class y.layout.hierarchic.<A HREF="../../../y/layout/hierarchic/AbstractDrawer.html" title="class in y.layout.hierarchic">AbstractDrawer</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#distanceToNextNode">distanceToNextNode</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#dummyMap">dummyMap</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#edgeLengthKey">edgeLengthKey</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#graph">graph</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#minimalEdgeDistance">minimalEdgeDistance</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#minimalLayerDistance">minimalLayerDistance</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#minimalMultiEdgeDistance">minimalMultiEdgeDistance</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#minimalNodeDistance">minimalNodeDistance</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_y.layout.hierarchic.Drawer"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from interface y.layout.hierarchic.<A HREF="../../../y/layout/hierarchic/Drawer.html" title="interface in y.layout.hierarchic">Drawer</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../y/layout/hierarchic/Drawer.html#NODE_BORDER_BOTTOM">NODE_BORDER_BOTTOM</A>, <A HREF="../../../y/layout/hierarchic/Drawer.html#NODE_BORDER_LEFT">NODE_BORDER_LEFT</A>, <A HREF="../../../y/layout/hierarchic/Drawer.html#NODE_BORDER_RIGHT">NODE_BORDER_RIGHT</A>, <A HREF="../../../y/layout/hierarchic/Drawer.html#NODE_BORDER_TOP">NODE_BORDER_TOP</A>, <A HREF="../../../y/layout/hierarchic/Drawer.html#NODE_DISTANCE">NODE_DISTANCE</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#PendularDrawer()">PendularDrawer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;empty constructor, does nothing</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#assignCoordinates(y.base.NodeList[], y.base.DataProvider)">assignCoordinates</A></B>(<A HREF="../../../y/base/NodeList.html" title="class in y.base">NodeList</A>[]&nbsp;layerLists,
                  <A HREF="../../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;layerID)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is the main loop of this layout algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#disposeStructures()">disposeStructures</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cleans up previously allocated structures, that were constructed by a call to 
 <code>initStructures</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../y/base/YList.html" title="class in y.base">YList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#findChains()">findChains</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds chains of nodes, i.e. maximum number of adjacent nodes (real ones and dummy nodes) have 
 indegree and outdegree 1.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#getEdgeWeight(y.base.Edge)">getEdgeWeight</A></B>(<A HREF="../../../y/base/Edge.html" title="class in y.base">Edge</A>&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a non-negative value for each Edge e.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#getMaximumExtent(y.base.Node, boolean)">getMaximumExtent</A></B>(<A HREF="../../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;n,
                 boolean&nbsp;toLeft)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates the highest or lowest x-coordinate the Node n can be assigned to, without breaking 
 the constraints.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#getMinimalLayerDistance(y.base.Node, boolean)">getMinimalLayerDistance</A></B>(<A HREF="../../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;n,
                        boolean&nbsp;toLeft)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimum distance between two Nodes on the same layer according to 
 getMinimalNodeDistance(), getMinimalEdgeDistance() and getMinimalMultiEdgeDistance().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#getPendulumForce(y.base.Node, y.base.EdgeCursor)">getPendulumForce</A></B>(<A HREF="../../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;v,
                 <A HREF="../../../y/base/EdgeCursor.html" title="interface in y.base">EdgeCursor</A>&nbsp;ec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Helper method which calculates the force that all nodes given by 
 EdgeCursor apply to v.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#getPendulumForce(y.base.YCursor, int)">getPendulumForce</A></B>(<A HREF="../../../y/base/YCursor.html" title="interface in y.base">YCursor</A>&nbsp;cursor,
                 int&nbsp;direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Helper method which calculates the force acting on all nodes given by the cursor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#getZ()">getZ</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates the value of the function this algorithm should minimize.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#initializePositions(y.base.NodeList[])">initializePositions</A></B>(<A HREF="../../../y/base/NodeList.html" title="class in y.base">NodeList</A>[]&nbsp;layerList)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Helper method which initializes the positions of the nodes in all layers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#initStructures()">initStructures</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;used to initialize internal structures such as <code>NodeMap right</code> and 
 <code>NodeMap left</code> <code>bendGridWidth</code> and <code>nodeGridWidth</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#isSegmentNode(y.base.Node)">isSegmentNode</A></B>(<A HREF="../../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Helper method that determines whether a node is a so-called segment node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#minNode()">minNode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs the minNode phase.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#minPath(y.base.YList)">minPath</A></B>(<A HREF="../../../y/base/YList.html" title="class in y.base">YList</A>&nbsp;segments)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs the minPath phase.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#move(y.base.Node, double)">move</A></B>(<A HREF="../../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;n,
     double&nbsp;distance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Helper method which moves a given node by a given amount
 if the useGrid is set to true, this method will snap the new node position to the
 appropriate grid, i.e. it decides whether to use nodeGridWith or bendGridWith</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#move(y.base.YCursor, double)">move</A></B>(<A HREF="../../../y/base/YCursor.html" title="interface in y.base">YCursor</A>&nbsp;nodes,
     double&nbsp;distance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Helper method which moves the nodes provided by the Cursor nodes by the given amount.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../y/base/YList.html" title="class in y.base">YList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#partitionLayer(y.base.NodeList, int)">partitionLayer</A></B>(<A HREF="../../../y/base/NodeList.html" title="class in y.base">NodeList</A>&nbsp;layer,
               int&nbsp;direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Partitions a layer given by its NodeList by calculating the forces 
 according to the given direction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#setLayoutGraph(y.layout.LayoutGraph)">setLayoutGraph</A></B>(<A HREF="../../../y/layout/LayoutGraph.html" title="class in y.layout">LayoutGraph</A>&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#shakePartition(y.base.YList, int)">shakePartition</A></B>(<A HREF="../../../y/base/YList.html" title="class in y.base">YList</A>&nbsp;partition,
               int&nbsp;direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shakes a given partition of a Layer, i.e. it calculates the forces for
 each part of the partition
 and applies them if possible.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#straightenPath(y.base.ListCell, y.base.ListCell, double[])">straightenPath</A></B>(<A HREF="../../../y/base/ListCell.html" title="class in y.base">ListCell</A>&nbsp;firstCell,
               <A HREF="../../../y/base/ListCell.html" title="class in y.base">ListCell</A>&nbsp;lastCell,
               double[]&nbsp;range)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Helper method for use in <code>minPath</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#touches(y.base.Node, y.base.Node)">touches</A></B>(<A HREF="../../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;v1,
        <A HREF="../../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;v2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Helper method which checks whether two adjacent nodes on a layer touch
 each other, i.e. their 
 distance is smaller than getMinimalLayerDistance(v1, ...)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#verifyMovement(y.base.Node, double)">verifyMovement</A></B>(<A HREF="../../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;n,
               double&nbsp;distance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assures that if distance was applied to the n's x-coordinate no given constraint gets broken.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_y.layout.hierarchic.AbstractDrawer"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class y.layout.hierarchic.<A HREF="../../../y/layout/hierarchic/AbstractDrawer.html" title="class in y.layout.hierarchic">AbstractDrawer</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#assignCoordinates(y.layout.LayoutGraph, y.base.NodeList[], y.base.DataProvider)">assignCoordinates</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#assignYCoords(y.layout.LayoutGraph, y.base.NodeCursor[])">assignYCoords</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#assignYCoords(y.layout.LayoutGraph, y.base.NodeList[])">assignYCoords</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#dispose()">dispose</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getBottomBorder(y.base.Node)">getBottomBorder</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getBottomHalf(y.base.Node)">getBottomHalf</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getBottomY(y.base.Node)">getBottomY</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getDistanceToNextNode(y.base.Node)">getDistanceToNextNode</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getFullHeight(y.base.Node)">getFullHeight</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getFullWidth(y.base.Node)">getFullWidth</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getLeftBorder(y.base.Node)">getLeftBorder</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getLeftHalf(y.base.Node)">getLeftHalf</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getLeftX(y.base.Node)">getLeftX</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getMinimalEdgeDistance()">getMinimalEdgeDistance</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getMinimalLayerDistance()">getMinimalLayerDistance</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getMinimalMultiEdgeDistance()">getMinimalMultiEdgeDistance</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getMinimalNodeDistance()">getMinimalNodeDistance</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getRightBorder(y.base.Node)">getRightBorder</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getRightHalf(y.base.Node)">getRightHalf</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getRightX(y.base.Node)">getRightX</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getTopBorder(y.base.Node)">getTopBorder</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getTopHalf(y.base.Node)">getTopHalf</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getTopY(y.base.Node)">getTopY</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#initializeDistancesToNextNode(y.base.NodeList[])">initializeDistancesToNextNode</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#setDummyMap(y.base.NodeMap)">setDummyMap</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#setEdgeLengthKey(java.lang.Object)">setEdgeLengthKey</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#setMinimalEdgeDistance(double)">setMinimalEdgeDistance</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#setMinimalLayerDistance(double)">setMinimalLayerDistance</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#setMinimalMultiEdgeDistance(double)">setMinimalMultiEdgeDistance</A>, <A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#setMinimalNodeDistance(double)">setMinimalNodeDistance</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang">finalize</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang">toString</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="right"><!-- --></A><H3>
right</H3>
<PRE>
protected <A HREF="../../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A> <B>right</B></PRE>
<DL>
<DD>map that maps the right node for each node in a layer or <code>null</code> if it is the rightmost
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="left"><!-- --></A><H3>
left</H3>
<PRE>
protected <A HREF="../../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A> <B>left</B></PRE>
<DL>
<DD>map that maps the left node for each node in a layer or <code>null</code> if it is the leftmost
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="PendularDrawer()"><!-- --></A><H3>
PendularDrawer</H3>
<PRE>
public <B>PendularDrawer</B>()</PRE>
<DL>
<DD>empty constructor, does nothing
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="initStructures()"><!-- --></A><H3>
initStructures</H3>
<PRE>
protected void <B>initStructures</B>()</PRE>
<DL>
<DD>used to initialize internal structures such as <code>NodeMap right</code> and 
 <code>NodeMap left</code> <code>bendGridWidth</code> and <code>nodeGridWidth</code>.
 Note that the NodeMaps do not yet contain any values unless you call initializePositions()
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="assignCoordinates(y.base.NodeList[], y.base.DataProvider)"><!-- --></A><H3>
assignCoordinates</H3>
<PRE>
protected void <B>assignCoordinates</B>(<A HREF="../../../y/base/NodeList.html" title="class in y.base">NodeList</A>[]&nbsp;layerLists,
                                 <A HREF="../../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;layerID)</PRE>
<DL>
<DD>This is the main loop of this layout algorithm. For now it does the following loop:
 <ul>
 <li> for each round do
        <ul>
        <li>top down phase, i.e. calling partitionLayer(layerList[i] , -1) 
        and shakePartition(partition,-1) for each layer in top down order</li>
        <li>bottom up phase, i.e. calling partitionLayer(layerList[i] , -1) 
        and shakePartition(partition,-1) for each layer in bottom up order</li>
        <li>criss cross phase, i.e. calling partitionLayer(layerList[i] , 0) 
        and shakePartition(partition,0) for each layer in top down order</li>
        <li>performing minNode</li>
   </ul></li>
 <li> minPath phase, i.e. calling findChains() and minPath(chains)</li>
 </ul>
 Subclasses that wish to override this function to implement different behaviour should
 implement a call to initStructures() and 
 initializePositions(layerLists) before using the provided methods.
 After the work is done, they should call disposeStructures(g).
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#assignCoordinates(y.base.NodeList[], y.base.DataProvider)">assignCoordinates</A></CODE> in class <CODE><A HREF="../../../y/layout/hierarchic/AbstractDrawer.html" title="class in y.layout.hierarchic">AbstractDrawer</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>layerLists</CODE> - a list of all the nodes for each layer, to determine
 their relative positions</DL>
</DD>
</DL>
<HR>

<A NAME="disposeStructures()"><!-- --></A><H3>
disposeStructures</H3>
<PRE>
protected void <B>disposeStructures</B>()</PRE>
<DL>
<DD>Cleans up previously allocated structures, that were constructed by a call to 
 <code>initStructures</code>
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#initStructures()"><CODE>initStructures()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="minPath(y.base.YList)"><!-- --></A><H3>
minPath</H3>
<PRE>
protected boolean <B>minPath</B>(<A HREF="../../../y/base/YList.html" title="class in y.base">YList</A>&nbsp;segments)</PRE>
<DL>
<DD>Performs the minPath phase.
 It tries to straighten the chains given by a list of NodeLists, by sequentially assigning the same
 x- coordinate to as many adjacent nodes of each chain as possible, not violating the constraints and 
 not changing coordinates of nodes in the neighborhood of each segment
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>segments</CODE> - a list of NodeList each containing a chain of nodes
<DT><B>Returns:</B><DD><code>true</code> iff there was a change in any coordinate of the graph<DT><B>See Also:</B><DD><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#findChains()"><CODE>findChains()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="findChains()"><!-- --></A><H3>
findChains</H3>
<PRE>
protected <A HREF="../../../y/base/YList.html" title="class in y.base">YList</A> <B>findChains</B>()</PRE>
<DL>
<DD>Finds chains of nodes, i.e. maximum number of adjacent nodes (real ones and dummy nodes) have 
 indegree and outdegree 1.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a list of NodeLists containing each more than 1 nodes<DT><B>See Also:</B><DD><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#minPath(y.base.YList)"><CODE>minPath(YList)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="straightenPath(y.base.ListCell, y.base.ListCell, double[])"><!-- --></A><H3>
straightenPath</H3>
<PRE>
protected boolean <B>straightenPath</B>(<A HREF="../../../y/base/ListCell.html" title="class in y.base">ListCell</A>&nbsp;firstCell,
                                 <A HREF="../../../y/base/ListCell.html" title="class in y.base">ListCell</A>&nbsp;lastCell,
                                 double[]&nbsp;range)</PRE>
<DL>
<DD>Helper method for use in <code>minPath</code>. 
 It will assign the same x-coordinate to all the nodes
 given the first and the last cell in NodeList. 
 Note that this method does not double-check whether the given
 range is valid for all nodes.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>firstCell</CODE> - this determines the first Node in a NodeList 
 which should be assigned a new x-coordinate<DD><CODE>lastCell</CODE> - this determines the last Node in a NodeList 
 (which must be same List as the one for firstCell) which should 
 be assigned a new x-coordinate<DD><CODE>range</CODE> - an interval providing information of the legal range,
 the Nodes x-coordinates could be set to.
 The values can can be smaller than (-Double.MAX_VALUE) for the left
 border and greater than Double.MAX_VALUE for the right one
<DT><B>Returns:</B><DD><CODE>true</CODE> iff this method has done any change to the graphs
 coordinates<DT><B>See Also:</B><DD><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#minPath(y.base.YList)"><CODE>minPath(YList)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isSegmentNode(y.base.Node)"><!-- --></A><H3>
isSegmentNode</H3>
<PRE>
protected boolean <B>isSegmentNode</B>(<A HREF="../../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;n)</PRE>
<DL>
<DD>Helper method that determines whether a node is a so-called segment node.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - the Node
<DT><B>Returns:</B><DD><code>true</code> iff (inDegree == 1 &amp;&amp; outDegree &lt; 2) ||
 (outDegree == 1 &amp;&amp; inDegree &lt; 2)</DL>
</DD>
</DL>
<HR>

<A NAME="minNode()"><!-- --></A><H3>
minNode</H3>
<PRE>
protected void <B>minNode</B>()</PRE>
<DL>
<DD>Performs the minNode phase.
 It uses a queue, which is initially filled with all nodes in the
 layout graph.
 For each Node n that is popped off the queue it performs a call to 
 <ul>
  <li>force = getPendulumForce(n, n.edges) </li>
  <li>force = verifyMovement(n,force)</li>
  <li>move(n, force)</li>
 </ul>
 If the node has changed its x-coordinate all its neighbors are requeued,
 if not already in the queue.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="shakePartition(y.base.YList, int)"><!-- --></A><H3>
shakePartition</H3>
<PRE>
protected void <B>shakePartition</B>(<A HREF="../../../y/base/YList.html" title="class in y.base">YList</A>&nbsp;partition,
                              int&nbsp;direction)</PRE>
<DL>
<DD>Shakes a given partition of a Layer, i.e. it calculates the forces for
 each part of the partition
 and applies them if possible.
 It uses the functionality of these methods:
 <ul>
  <li>getPendulumForce(NodeCursor, int direction)</li>
  <li>verifyMovement(Node, double force)</li>
  <li>move(NodeCursor, double force)</li>
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>partition</CODE> - a List of NodeLists each containing at least one node
 belonging to a single layer<DD><CODE>direction</CODE> - -1 if nodes in higher layers should be used to calculate
 the forces, 1 if nodes in lower layers should be used, 0 if both
 surrounding layers should be used<DT><B>See Also:</B><DD><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#partitionLayer(y.base.NodeList, int)"><CODE>partitionLayer(NodeList,int)</CODE></A>, 
<A HREF="../../../y/layout/hierarchic/PendularDrawer.html#getPendulumForce(y.base.YCursor, int)"><CODE>getPendulumForce(YCursor, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="partitionLayer(y.base.NodeList, int)"><!-- --></A><H3>
partitionLayer</H3>
<PRE>
protected <A HREF="../../../y/base/YList.html" title="class in y.base">YList</A> <B>partitionLayer</B>(<A HREF="../../../y/base/NodeList.html" title="class in y.base">NodeList</A>&nbsp;layer,
                               int&nbsp;direction)</PRE>
<DL>
<DD>Partitions a layer given by its NodeList by calculating the forces 
 according to the given direction.
 This one is intended for use with the shakePartition() method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>layer</CODE> - the layer which shall be partitioned<DD><CODE>direction</CODE> - -1 if nodes in higher layers should be used to calculate
 the forces, 1 if nodes in lower layers 
 should be used, 0 if both surrounding layers should be used
<DT><B>Returns:</B><DD>a list of NodeLists each containing adjacent nodes in that layer,
 which can be treated as a single unit when moving<DT><B>See Also:</B><DD><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#getPendulumForce(y.base.YCursor, int)"><CODE>getPendulumForce(y.base.YCursor, int)</CODE></A>, 
<A HREF="../../../y/layout/hierarchic/PendularDrawer.html#touches(y.base.Node, y.base.Node)"><CODE>touches(y.base.Node, y.base.Node)</CODE></A>, 
<A HREF="../../../y/layout/hierarchic/PendularDrawer.html#shakePartition(y.base.YList, int)"><CODE>shakePartition(y.base.YList, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setLayoutGraph(y.layout.LayoutGraph)"><!-- --></A><H3>
setLayoutGraph</H3>
<PRE>
protected void <B>setLayoutGraph</B>(<A HREF="../../../y/layout/LayoutGraph.html" title="class in y.layout">LayoutGraph</A>&nbsp;g)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPendulumForce(y.base.Node, y.base.EdgeCursor)"><!-- --></A><H3>
getPendulumForce</H3>
<PRE>
protected double <B>getPendulumForce</B>(<A HREF="../../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;v,
                                  <A HREF="../../../y/base/EdgeCursor.html" title="interface in y.base">EdgeCursor</A>&nbsp;ec)</PRE>
<DL>
<DD>Helper method which calculates the force that all nodes given by 
 EdgeCursor apply to v.
 The force is calculated by the sum of the weighted differences of the 
 x-coordinates.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - the node for which the force will be calculated<DD><CODE>ec</CODE> - the EdgeCursor which determines which edges should be 
 considered in the calculation
<DT><B>Returns:</B><DD>a force, i.e. a signed value, which (if added to the x-coordinate
 of v) would minimize the force on v if applied.<DT><B>See Also:</B><DD><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#getEdgeWeight(y.base.Edge)"><CODE>getEdgeWeight(Edge)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="touches(y.base.Node, y.base.Node)"><!-- --></A><H3>
touches</H3>
<PRE>
protected boolean <B>touches</B>(<A HREF="../../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;v1,
                          <A HREF="../../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;v2)</PRE>
<DL>
<DD>Helper method which checks whether two adjacent nodes on a layer touch
 each other, i.e. their 
 distance is smaller than getMinimalLayerDistance(v1, ...)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v1</CODE> - one node<DD><CODE>v2</CODE> - another node
<DT><B>Returns:</B><DD><code>true</code> iff their distance is smaller than
 getMinimalLayerDistance+EPSILON<DT><B>See Also:</B><DD><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#getMinimalLayerDistance(y.base.Node, boolean)"><CODE>getMinimalLayerDistance(Node,boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="verifyMovement(y.base.Node, double)"><!-- --></A><H3>
verifyMovement</H3>
<PRE>
protected double <B>verifyMovement</B>(<A HREF="../../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;n,
                                double&nbsp;distance)</PRE>
<DL>
<DD>Assures that if distance was applied to the n's x-coordinate no given constraint gets broken.
 It makes extensive use of getMinimalLayerDistance(v1, ...)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - the node to be moved<DD><CODE>distance</CODE> - the distance which shall be verified
<DT><B>Returns:</B><DD>the distance which can be applied to n without breaking any constraint<DT><B>See Also:</B><DD><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#getMinimalLayerDistance(y.base.Node, boolean)"><CODE>getMinimalLayerDistance(Node,boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getPendulumForce(y.base.YCursor, int)"><!-- --></A><H3>
getPendulumForce</H3>
<PRE>
protected double <B>getPendulumForce</B>(<A HREF="../../../y/base/YCursor.html" title="interface in y.base">YCursor</A>&nbsp;cursor,
                                  int&nbsp;direction)</PRE>
<DL>
<DD>Helper method which calculates the force acting on all nodes given by the cursor.
 The force is calculated by the sum of the results of calls to getPendulumForce(Node, int)
 divided by the number of the nodes.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cursor</CODE> - the nodes for which the force will be calculated<DD><CODE>direction</CODE> - -1 if nodes in higher layers should be used to calculate the forces, 1 if nodes 
 in lower layers should be used, 0 if both surrounding layers should be used
<DT><B>Returns:</B><DD>a force, i.e. a signed value, which, if applied to the nodes in cursor, would minimize 
 the force acting on them.</DL>
</DD>
</DL>
<HR>

<A NAME="move(y.base.Node, double)"><!-- --></A><H3>
move</H3>
<PRE>
protected void <B>move</B>(<A HREF="../../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;n,
                    double&nbsp;distance)</PRE>
<DL>
<DD>Helper method which moves a given node by a given amount
 if the useGrid is set to true, this method will snap the new node position to the
 appropriate grid, i.e. it decides whether to use nodeGridWith or bendGridWith
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - the node<DD><CODE>distance</CODE> - the distance that shall be added to the nodes x-coordinate</DL>
</DD>
</DL>
<HR>

<A NAME="move(y.base.YCursor, double)"><!-- --></A><H3>
move</H3>
<PRE>
protected void <B>move</B>(<A HREF="../../../y/base/YCursor.html" title="interface in y.base">YCursor</A>&nbsp;nodes,
                    double&nbsp;distance)</PRE>
<DL>
<DD>Helper method which moves the nodes provided by the Cursor nodes by the given amount.
 This one in turn calls move(Node,double) to delegate its work.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodes</CODE> - the nodes<DD><CODE>distance</CODE> - the distance that shall be added to the nodes x-coordinate<DT><B>See Also:</B><DD><A HREF="../../../y/layout/hierarchic/PendularDrawer.html#move(y.base.Node, double)"><CODE>move(Node,double)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getZ()"><!-- --></A><H3>
getZ</H3>
<PRE>
protected double <B>getZ</B>()</PRE>
<DL>
<DD>Calculates the value of the function this algorithm should minimize.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a positive value.</DL>
</DD>
</DL>
<HR>

<A NAME="getEdgeWeight(y.base.Edge)"><!-- --></A><H3>
getEdgeWeight</H3>
<PRE>
protected double <B>getEdgeWeight</B>(<A HREF="../../../y/base/Edge.html" title="class in y.base">Edge</A>&nbsp;e)</PRE>
<DL>
<DD>Returns a non-negative value for each Edge e.
 In this implementation edges between two real nodes result in an edge weight of 1.
 Edges between one dummy and one real node result in an edge weight of 
 <code>segmentEndFactor * 1</code>.
 Edges between two dummy nodes get an edge weight of <code>segmentFactor * 1</code>.
 One could implement edge weights by supplying an <code>EdgeMap</code> mapping a non-negative
 numeric value for each edge.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>e</CODE> - the edge
<DT><B>Returns:</B><DD>a non-negative value</DL>
</DD>
</DL>
<HR>

<A NAME="getMaximumExtent(y.base.Node, boolean)"><!-- --></A><H3>
getMaximumExtent</H3>
<PRE>
protected double <B>getMaximumExtent</B>(<A HREF="../../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;n,
                                  boolean&nbsp;toLeft)</PRE>
<DL>
<DD>Calculates the highest or lowest x-coordinate the Node n can be assigned to, without breaking 
 the constraints.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - the node<DD><CODE>toLeft</CODE> - <code>true</code> if the minimum x-coordinate shall be calculated; 
 <code>false</code> for the maximum x-coordinate
<DT><B>Returns:</B><DD>the maximum/minimum extent of the node's center x-coordinate</DL>
</DD>
</DL>
<HR>

<A NAME="getMinimalLayerDistance(y.base.Node, boolean)"><!-- --></A><H3>
getMinimalLayerDistance</H3>
<PRE>
protected double <B>getMinimalLayerDistance</B>(<A HREF="../../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;n,
                                         boolean&nbsp;toLeft)</PRE>
<DL>
<DD>Returns the minimum distance between two Nodes on the same layer according to 
 getMinimalNodeDistance(), getMinimalEdgeDistance() and getMinimalMultiEdgeDistance().
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - the node<DD><CODE>toLeft</CODE> - <code>true</code> if the minimum x-coordinate shall be calculated; 
 <code>false</code> for the maximum x-coordinate
<DT><B>Returns:</B><DD>the maximum/minimum extent of the node's center x-coordinate<DT><B>See Also:</B><DD><A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getMinimalMultiEdgeDistance()"><CODE>AbstractDrawer.getMinimalMultiEdgeDistance()</CODE></A>, 
<A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getMinimalNodeDistance()"><CODE>AbstractDrawer.getMinimalNodeDistance()</CODE></A>, 
<A HREF="../../../y/layout/hierarchic/AbstractDrawer.html#getMinimalEdgeDistance()"><CODE>AbstractDrawer.getMinimalEdgeDistance()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="initializePositions(y.base.NodeList[])"><!-- --></A><H3>
initializePositions</H3>
<PRE>
protected void <B>initializePositions</B>(<A HREF="../../../y/base/NodeList.html" title="class in y.base">NodeList</A>[]&nbsp;layerList)</PRE>
<DL>
<DD>Helper method which initializes the positions of the nodes in all layers.
 This method respects getMinimalLayerDistance(Node,boolean)
 and compacts the graph to the leftmost position (0)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>layerList</CODE> - an array of NodeLists each corresponding to a single layer</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<ADDRESS><FONT CLASS="CopyrightFooterFont"><I>&#169; Copyright 2000-2010,<BR><A HREF="http://www.yworks.com" TARGET="_top">yWorks GmbH</A>.<BR>All rights reserved.</I></FONT></ADDRESS></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../y/layout/hierarchic/NodeLabelSpaceDrawer.html" title="class in y.layout.hierarchic"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../y/layout/hierarchic/PolylineDrawer.html" title="class in y.layout.hierarchic"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?y/layout/hierarchic/PendularDrawer.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="PendularDrawer.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
